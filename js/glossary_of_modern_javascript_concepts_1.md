# Глоссарий современных концепций JavaScript: Часть 1

### Изучите основы функционального программирования, реактивного программирования и функционально-реактивного программирования на JavaScript.

Автор [оригинала](https://auth0.com/blog/glossary-of-modern-javascript-concepts/): Kim Maida

14 февраля 2017

В первой части серии "Глоссарий современных концепций JS" мы получим представление о _функциональном программировании_, _реактивном программировании_ и _функционально-реактивном программировании_. Для этого мы узнаем о чистоте, statefulness и statelessness, immutability и mutability, императивном и декларативном программировании, функциях высшего порядка, observables и парадигмах FP, RP и FRP.

Современный JavaScript за последние годы пережил массовое распространение и не подает признаков замедления. Многие концепции, появляющиеся в блогах и документации по JS, все еще незнакомы многим разработчикам front-end. В этой серии статей мы познакомимся с промежуточными и продвинутыми концепциями в современном ландшафте front-end программирования и рассмотрим, как они применяются к современному JavaScript.

Чистота: Чистые функции, нечистые функции, побочные эффекты
------------------------------------------------------

### Чистые функции

У **чистой функции** _обратное значение_ определяется только ее _входными значениями_ (аргументами) без побочных эффектов. При передаче одного и того же аргумента результат всегда будет одинаковым. Вот пример:

```js
    function half(x) {
      возвращает x / 2;
    }
```

Функция `half(x)` принимает число `x` и возвращает значение половины `x`. Если мы передадим этой функции аргумент `8`, функция всегда будет возвращать `4`. При вызове чистая функция может быть заменена своим результатом. Например, мы можем заменить `half(8)` на `4` везде, где она используется в нашем коде, без изменения конечного результата. Это называется [_ссылочной прозрачностью_](https://en.wikipedia.org/wiki/Referential_transparency).

Чистые функции зависят только от того, что им передано. Например, чистая функция не может ссылаться на переменные из родительской области видимости, если они явно не переданы в функцию в качестве аргументов. Даже в этом случае функция не может _изменить_ родительскую область видимости.

```js
    // некоторая переменная, которая изменяется
    let someNum = 8;
    
    // это НЕ чистая функция
    функция impureHalf() {
      return someNum / 2;
    }
```

Итого:

* Чистые функции должны принимать аргументы.
* Один и тот же вход (аргументы) всегда будет давать один и тот же выход (return).
* Чистые функции полагаются только на локальное состояние и не изменяют внешнее состояние (_примечание:_ `console.log` изменяет глобальное состояние).
* Чистые функции не производят [побочных эффектов] (https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29).
* Чистые функции не могут вызывать нечистые функции.

### Нечистые функции

**Нечистая функция** изменяет состояние за пределами своей области видимости. Любая функция, которая имеет _побочные эффекты_ (см. ниже), является нечистой.

Рассмотрим следующие примеры:

```js
    // нечистая функция, производящая побочный эффект
    функция showAlert() {
      alert('Это побочный эффект!');
    }
    
    // нечистая функция, мутирующая внешнее состояние
    var globalVal = 1;
    function incrementGlobalVal(x) {
      globalVal += x;
    }
    
    // нечистая функция, которая похожа на чистую функцию,
    // но возвращает разные результаты при одинаковых входных данных
    function getRandomRange(min, max) {
      return Math.random() * (max - min) + min;
    }
```

### Побочные эффекты в JavaScript

Когда функция или выражение изменяет состояние вне своего контекста, результат является **побочным эффектом**. Примерами побочных эффектов являются вызов API, манипуляции с DOM, появление диалогового окна предупреждения, запись в базу данных и т.д. Если функция производит побочные эффекты, она считается _нечистой_. Функции, вызывающие побочные эффекты, менее предсказуемы и их труднее тестировать, поскольку они приводят к изменениям за пределами локальной области видимости.

### Выводы по чистоте

Множество качественного кода состоит из _нечистых_ функций, которые процедурно вызывают _чистые_ функции. Это по-прежнему дает преимущества для тестирования и неизменяемости. Ссылочная прозрачность также позволяет [_мемоизацию_](https://www.interviewcake.com/concept/python/memoization): кэширование и хранение результатов вызова функций и [повторное использование кэшированных результатов](https://www.sitepoint.com/implementing-memoization-in-javascript/) при повторном использовании тех же входных данных. Определить, когда функции действительно чисты, может быть непросто.

Чтобы узнать больше о **чистоте**, ознакомьтесь со следующими ресурсами:

* [Чистые и нечистые функции](https://toddmotto.com/pure-versus-impure-functions)
* [Master the JavaScript Interview: What is a Pure Function?](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976#.kt48h2bfa)
* [Функциональное программирование: чистые функции](https://www.sitepoint.com/functional-programming-pure-functions/)

* * *

Состояние
-----

**Состояние** относится к информации, к которой программа имеет доступ и может работать в определенный момент времени. Сюда входят данные, хранящиеся в памяти, а также память ОС, порты ввода/вывода, база данных и т.д. Например, содержимое переменных в приложении в любой момент времени является показателем _состояния_ приложения.

### Stateful

**Stateful** программы, приложения или компоненты хранят в памяти данные о текущем состоянии. Они могут изменять состояние, а также получать доступ к его истории. Следующий пример является _stateful_:

```js
    // stateful
    var number = 1;
    function increment() {
      return number++;
    }
    increment(); // глобальная переменная изменена: number = 2
```

### Stateless

**Stateless** функции или компоненты выполняют задачи так, как будто они запускаются впервые, каждый раз. Это означает, что они не ссылаются и не используют информацию, полученную ранее в процессе выполнения. Нестационарность обеспечивает _референтную прозрачность_. Функции зависят только от своих аргументов и не обращаются к чему-либо за пределами своей области видимости. [Чистые функции](#purity) не имеют состояния. См. следующий пример:

```js
    // stateless
    var number = 1;
    function increment(n) {
      return n + 1;
    }
    increment(number); // глобальная переменная НЕ изменена: возвращается 2
```

Приложения без состояния _до сих пор управляют состоянием. Однако они возвращают свое текущее состояние без _изменения_ предыдущего состояния. Это постулат [функционального программирования](#functional-programming).

### Выводы по управлению состоянием

Управление состоянием важно для любого сложного приложения. Функции или компоненты с состоянием изменяют состояние и хранят историю, но их сложнее тестировать и отлаживать. Функции без состояния полагаются только на свои входные данные для получения выходных. Программа без состояния возвращает новое состояние, а не _изменяет_ существующее.

Чтобы узнать больше о **состоянии**, ознакомьтесь со следующими ресурсами:

* [Состояние](https://en.wikipedia.org/wiki/State_(computer_science))
* [Преимущества программирования без состояния](http://stackoverflow.com/questions/844536/advantages-of-stateless-programming)
* [Stateful and stateless components, the missing manual](https://toddmotto.com/stateful-stateless-components)
* [Redux: предсказуемый контейнер состояний для JavaScript-приложений](http://redux.js.org/)

* * *

Неизменность и изменчивость
---------------------------

Понятия **неизменяемость и изменяемость** в JavaScript несколько более туманны, чем в некоторых других языках программирования. Однако, читая о [функциональном программировании](#functional-programming) на JS, вы будете часто слышать о неизменяемости. Важно знать, что эти термины означают классически, а также как они упоминаются и реализуются в JavaScript. Определения достаточно просты:

### Неизменяемые (Immutable)

Если объект **неизменяемый**, его значение не может быть изменено после создания.

### Изменяемые (Mutable)

Если объект **mutable**, его значение может быть изменено после создания.

### По конструкции: неизменяемость и изменяемость в JavaScript

В JavaScript строки и числовые литералы являются _неизменяемыми по замыслу_. Это легко понять, если рассмотреть, как мы оперируем ими:

```js
    var str = 'Hello!';
    var anotherStr = str.substring(2);
    // результат: str = 'Hello!' (без изменений)
    // результат: anotherStr = 'llo!' (новая строка)
```

Использование метода `.substring()` для нашей строки `Hello!` _не_ изменяет исходную строку. Вместо этого создается _новая_ строка. Мы можем переназначить _переменное значение `str` на что-то другое, но после создания нашей строки `Hello!` она всегда будет `Hello!`.

Числовые литералы также неизменяемы. Следующие действия всегда будут иметь один и тот же результат:

```js
    var 3 = 1 + 2;
    // результат: три = 3
```

Ни при каких обстоятельствах `1 + 2` не может быть оценено ничем иным, кроме как `3`.

Это показывает, что неизменяемость по замыслу существует в JavaScript. Однако разработчики JS знают, что язык позволяет изменять большинство вещей. Например, объекты и массивы являются _изменяемыми по замыслу_. Рассмотрим следующее:

```js
    var arr = [1, 2, 3];
    arr.push(4);
    // результат: arr = [1, 2, 3, 4].
    
    var obj = { greeting: 'Hello' };
    obj.name = 'Jon';
    // результат: obj = { greeting: 'Hello', name: 'Jon' }
```

В этих примерах мутируют _оригинальные_ объекты. Новые объекты не возвращаются.

Чтобы узнать больше о мутабельности в других языках, ознакомьтесь с [Mutable vs Immutable Objects](https://www.interviewcake.com/concept/java/mutable).

### На практике: неизменяемость в JavaScript

[Функциональное программирование](#functional-programming)

в JavaScript набрало много оборотов. Но по своей конструкции, JS - очень изменчивый, мультипарадигмальный язык. Функциональное программирование подчеркивает _изменяемость_. Другие функциональные языки будут выдавать ошибки, когда разработчик попытается изменить неизменяемый объект. Как же примирить врожденную мутабельность JS при написании функционального или функционально-реактивного JS?

Когда мы говорим о функциональном программировании на JS, слово "неизменяемый" используется часто, но ответственность за написание кода с учетом неизменяемости лежит на разработчике. Например, [Redux полагается на единое неизменяемое дерево состояний](https://egghead.io/lessons/javascript-redux-the-single-immutable-state-tree). Однако сам _JavaScript_ способен изменять объект состояния. Чтобы реализовать неизменяемое дерево состояний, нам нужно [возвращать _новый_](https://egghead.io/lessons/javascript-redux-avoiding-array-mutations-with-concat-slice-and-spread) [объект состояния](https://egghead.io/lessons/javascript-redux-avoiding-object-mutations-with-object-assign-and-spread) каждый раз, когда состояние изменяется.

Объекты JavaScript [также могут быть заморожены](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) с помощью `Object.freeze(obj)` [чтобы сделать их неизменяемыми](http://adripofjavascript.com/blog/drips/immutable-objects-with-object-freeze.html). Обратите внимание, что это _неглубокий_ метод, то есть значения объектов внутри замороженного объекта все еще могут быть изменены. Для дальнейшего обеспечения неизменяемости [функции, подобные Mozilla's deepFreeze()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) и [npm deep-freeze](https://www.npmjs.com/package/deep-freeze), могут рекурсивно замораживать объекты. Замораживание наиболее целесообразно использовать в _тестах_, а не в JS приложениях. Тесты предупреждают разработчиков о возникновении мутаций, чтобы их можно было исправить или избежать в реальной сборке без `Object.freeze`, загромождающего основной код.

Существуют также библиотеки для поддержки неизменяемости в JS. [Mori](http://swannodette.github.io/mori/) предоставляет постоянные структуры данных, основанные на Clojure. [Immutable.js](https://facebook.github.io/immutable-js/) от Facebook также предоставляет [неизменяемые коллекции для JS](https://auth0.com/blog/intro-to-immutable-js/). Утилитарные библиотеки, такие как [Underscore.js](http://underscorejs.org) и [lodash](http://www.lodash.com), предоставляют методы и модули для продвижения более неизменяемого [функционального стиля программирования](https://github.com/lodash/lodash/wiki/FP-Guide).


### Неизменяемость и изменяемость. Выводы

В целом, JavaScript - очень изменчивый язык. Некоторые стили JS-кодирования _полагаются_ на эту врожденную изменчивость. Однако при написании функционального JS реализация неизменяемости требует внимательности. JS не будет изначально выдавать ошибки, если вы непреднамеренно что-то измените. Тестирование и библиотеки могут помочь, но работа с неизменяемостью в JS требует практики и методологии.

Неизменяемость имеет свои преимущества. Она приводит к тому, что код становится более простым для рассуждений. Она также обеспечивает [_персистентность_](https://en.wikipedia.org/wiki/Persistence_(computer_science)) - возможность сохранять старые версии структуры данных и копировать только те части, которые изменились.

Недостатком неизменяемости является то, что многие алгоритмы и операции не могут быть реализованы эффективно.

Чтобы узнать больше о **неизменяемости и изменяемости**, ознакомьтесь со следующими ресурсами:

* [Immutability in JavaScript](https://www.sitepoint.com/immutability-javascript/)
* [Неизменяемые объекты с Object Freeze](http://adripofjavascript.com/blog/drips/immutable-objects-with-object-freeze.html)
* [Mutable vs Immutable Objects](https://www.interviewcake.com/concept/java/mutable)
* [Using Immutable Data Stuctures in JavaScript](http://jlongster.com/Using-Immutable-Data-Structures-in-JavaScript)
* [Начало работы с Redux](https://egghead.io/courses/getting-started-with-redux) (включает примеры для работы с неизменяемым состоянием)

* * *

Императивное и декларативное программирование
--------------------------------------

В то время как некоторые языки были разработаны как **императивные** (C, PHP) или **декларативные** (SQL, HTML), JavaScript (и другие, такие как [Java](http://openjdk.java.net/projects/lambda/) и [C#](https://msdn.microsoft.com/en-us/library/bb534803(v=vs.110).aspx)) может поддерживать обе парадигмы программирования.

Большинство разработчиков, знакомых даже с самым простым JavaScript, писали императивный код: инструкции, информирующие компьютер о том, _как_ достичь желаемого результата. Если вы написали цикл `for`, вы написали императивный JS.

Декларативный код сообщает компьютеру _что_ вы хотите достичь, а не как, и компьютер заботится о том, как достичь конечного результата без явного описания со стороны разработчика. Если вы использовали `Array.map`, вы написали декларативный JS.

### Императивное программирование

**Императивное программирование** описывает _как_ работает логика программы в явных командах с утверждениями, которые изменяют состояние программы.

Рассмотрим функцию, которая увеличивает каждое число в массиве целых чисел. Примером императивного JavaScript может быть:

```js
    function incrementArray(arr) {
      let resultArr = [];
      for (let i = 0; i < arr.length; i++) {
        resultArr.push(arr[i] + 1);
      }
      return resultArr;
    }
```

Эта функция показывает, как именно работает логика функции: мы выполняем итерации по массиву и явно увеличиваем каждое число, заталкивая его в новый массив. Затем мы возвращаем результирующий массив. Это пошаговое описание логики работы функции.

### Декларативное программирование

**Декларативное программирование** описывает _что_ делает логика программы, не описывая как.

Очень простой пример декларативного программирования можно продемонстрировать на примере [SQL](https://www.khanacademy.org/computing/computer-programming/sql). Мы можем запросить таблицу базы данных (`People`) для поиска людей с фамилией `Smith` следующим образом:

```sql
    SELECT * FROM People WHERE LastName = 'Smith'.
```

Этот код легко читается и описывает _что_ мы хотим достичь. Здесь нет описания того, как именно результат должен быть достигнут. Об этом позаботится компьютер.

Теперь рассмотрим функцию `incrementArray()`, которую мы реализовали императивно выше. Давайте теперь реализуем ее декларативно:

```js
    function incrementArray(arr) {
      return arr.map(item => item + 1);
    }
```

Мы показываем _что_ мы хотим достичь, но не то, как это работает. Метод [`Array.map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) возвращает новый массив с результатами выполнения обратного вызова для каждого элемента из переданного массива. Этот подход не изменяет существующие значения и не включает никакой последовательной логики, показывающей _как_ он создает новый массив.

> **Примечание:** Методы JavaScript [`map`, `reduce`,](https://www.sitepoint.com/map-reduce-functional-javascript/) [и `filter`](https://danmartensen.svbtle.com/javascripts-map-reduce-and-filter) являются декларативными, [функциональными](#functional-programming) методами массивов. Утилитарные библиотеки, такие как [lodash](https://lodash.com/), предоставляют такие методы как [`takeWhile`](https://lodash.com/docs/4.17.4#takeWhile), [`uniq`](https://lodash.com/docs/4.17.4#uniq), [`zip`](https://lodash.com/docs/4.17.4#zip) и другие в дополнение к `map`, `reduce` и `filter`.

### Выводы императивного и декларативного программирования

Как язык, JavaScript допускает как **императивное, так и декларативное программирование**. Большая часть кода на JS, который мы читаем и пишем, является императивным. Однако с развитием [функционального программирования](#functional-programming) в JS, декларативные подходы становятся все более распространенными.

Декларативное программирование имеет очевидные преимущества в плане краткости и читабельности, но в то же время оно может показаться магическим. Многим начинающим JavaScript полезно получить опыт написания императивного JS, прежде чем погружаться слишком глубоко в декларативное программирование.

Чтобы узнать больше о **императивном и декларативном программировании**, ознакомьтесь со следующими ресурсами:

* [Imperative vs Declarative Programming](https://tylermcginnis.com/imperative-vs-declarative-programming/)
* [В чем разница между императивным, процедурным и структурным программированием?](http://softwareengineering.stackexchange.com/questions/117092/whats-the-difference-between-imperative-procedural-and-structured-programming)
* [Императивное и (функциональное) декларативное JS на практике](http://www.redotheweb.com/2015/09/18/declarative-imperative-js.html)
* [Map, Reduce и Filter в JavaScript](https://danmartensen.svbtle.com/javascripts-map-reduce-and-filter)

* * *

Функции высшего порядка
----------------------

Функция **высшего порядка** - это функция, которая:

* принимает другую функцию в качестве аргумента, или
* возвращает функцию в качестве результата.

В JavaScript функции являются [_объектами первого класса_](http://helephant.com/2008/08/19/functions-are-first-class-objects-in-javascript/). Их можно хранить и передавать как _значения_: мы можем присвоить функцию переменной или передать функцию другой функции.

```js
    const double = function(x) {
      return x * 2;
    }
    const timesTwo = double;
    
    timesTwo(4); // результат: возвращает 8
```

Одним из примеров принятия функции в качестве аргумента является _обратный вызов_. Обратные вызовы могут быть встроенными анонимными функциями или именованными функциями:

```js
    const myBtn = document.getElementById('myButton');
    
    // анонимная функция обратного вызова
    myBtn.addEventListener('click', function(e) { console.log(`Событие щелчка: ${e}`); });
    
    // именованная функция обратного вызова
    function btnHandler(e) {
      console.log(`Событие щелчка: ${e}`);
    }
    myBtn.addEventListener('click', btnHandler);
```

Мы также можем передать функцию в качестве аргумента любой другой созданной нами функции и затем выполнить ее:

```js
    function sayHi() {
      alert('Hi!');
    }
    function greet(greeting) {
      greeting();
    }
    greet(sayHi); // оповещает "Привет!".
```

> **Примечание:** При _передаче именованной функции в качестве аргумента_, как в двух примерах выше, мы не используем круглые скобки `()`. Таким образом, мы передаем функцию как объект. Круглые скобки _выполняют_ функцию и передают результат вместо самой функции.

Функции высшего порядка также могут возвращать другую функцию:

```js
    function whenMeetingJohn() {
      return function() {
        alert('Hi!');
      }
    }
    var atLunchToday = whenMeetingJohn();
    
    atLunchToday(); // оповещает "Привет!".
```

### Выводы по функциям высшего порядка

Природа функций JavaScript как объектов первого класса делает их идеальными для облегчения [функционального программирования] (#functional-programming).

Чтобы узнать больше о **функциях высшего порядка**, ознакомьтесь со следующими ресурсами:

* [Функции - объекты первого класса в JavaScript](http://helephant.com/2008/08/19/functions-are-first-class-objects-in-javascript/)
* [Функции высшего порядка в JavaScript](https://www.sitepoint.com/higher-order-functions-javascript/)
* [Функции высшего порядка - часть 1 функционального программирования на JavaScript](https://www.youtube.com/watch?v=BMUiFMZr7vk)
* [Красноречивый JavaScript - Функции высшего порядка](http://eloquentjavascript.net/05_higher_order.html)
* [Функции высшего порядка](https://medium.com/functional-javascript/higher-order-functions-78084829fff4#.dwg58papp)

* * *

Функциональное программирование
----------------------

Теперь мы узнали о чистоте, отсутствии статичности, неизменяемости, декларативном программировании и функциях высшего порядка. Все эти понятия важны для понимания парадигмы функционального программирования.

### На практике: Функциональное программирование на JavaScript

**Функциональное программирование** включает в себя вышеперечисленные концепции следующим образом:

* Основная функциональность реализуется с помощью чистых функций без побочных эффектов.
* Данные неизменяемы.
* Функциональные программы не имеют состояния.
* Императивный контейнерный код управляет побочными эффектами и выполняет декларативный, чистый основной код.\*

> Если бы мы попытались написать веб-приложение на JavaScript, состоящее только из чистых функций без побочных эффектов, оно не смогло бы взаимодействовать с окружением и, следовательно, не было бы особенно полезным.

Давайте рассмотрим пример. Допустим, у нас есть текст, и мы хотим получить количество слов в нем. Мы также хотим найти ключевые слова, длина которых превышает пять символов. Используя функциональное программирование, наш результирующий код мог бы выглядеть примерно так:

```js
    const fpCopy = `Функциональное программирование мощное и приятное в написании. Это очень круто!
    
    // удаляем пунктуацию из строки
    const stripPunctuation = (str) =>
      str.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '');
    
    // разбиваем переданную строку на пробелы для создания массива
    const getArr = (str) =>
      str.split(' ');
    
    // подсчет элементов в переданном массиве
    const getWordCount = (arr) =>
      arr.length;
    
    // найти элементы в переданном массиве длиннее 5 символов
    // сделать элементы в нижнем регистре
    const getKeywords = (arr) =>
      arr
        .filter(item => item.length > 5)
        .map(item => item.toLowerCase());
    
    // обрабатываем копию для подготовки строки, создания массива, подсчета слов и получения ключевых слов
    function processCopy(str, prepFn, arrFn, countFn, kwFn) {
      const copyArray = arrFn(prepFn(str));
    
      console.log(`Счетчик слов: ${countFn(copyArray)}`);
      console.log(`Keywords: ${kwFn(copyArray)}`);
    }
    
    processCopy(fpCopy, stripPunctuation, getArr, getWordCount, getKeywords);
    // результат: Количество слов: 11
    // результат: Ключевые слова: функциональный, программирование, мощный, приятный
```

Этот код доступен для выполнения на этом сайте [JSFiddle: Functional Programming with JavaScript](https://jsfiddle.net/kmaida/xxc7g0ve/). Он разбит на легко усваиваемые, декларативные функции с четким назначением. Если мы пройдем через него и прочитаем комментарии, дальнейшее объяснение кода не потребуется. Каждая функция _ядра_ является модульной и полагается только на свои входные данные ([pure](#purity)). Последняя функция обрабатывает ядро для создания коллективных выходов. Эта функция, `processCopy()`, является нечистым контейнером, который выполняет ядро и управляет побочными эффектами. Мы использовали [функцию высшего порядка](#higher-order-functions), которая принимает другие функции в качестве аргументов, чтобы сохранить функциональный стиль.

### Выводы из функционального программирования

Неизменяемые данные и отсутствие статичности означают, что существующее состояние программы не изменяется. Вместо этого возвращаются новые значения. Чистые функции используются для основной функциональности. Для реализации программы и обработки необходимых побочных эффектов нечистые функции могут вызывать чистые функции в обязательном порядке.

Чтобы узнать больше о **функциональном программировании**, ознакомьтесь со следующими ресурсами:

* [Введение в Immutable.js и концепции функционального программирования](https://auth0.com/blog/intro-to-immutable-js/)
* [Functional Programming For The Rest of Us](http://www.defmacro.org/ramblings/fp.html)
* [Functional Programming with JavaScript](http://stephen-young.me.uk/2013/01/20/functional-programming-with-javascript.html)
* [Don't be Scared of Functional Programming](https://www.smashingmagazine.com/2014/07/dont-be-scared-of-functional-programming/)
* [So You Want to be a Functional Programmer](https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536#.q8a7nwjat)
* [lodash - руководство по функциональному программированию](https://github.com/lodash/lodash/wiki/FP-Guide)
* [В чем разница между функциональными и императивными языками программирования?](http://stackoverflow.com/questions/17826380/what-is-difference-between-functional-and-imperative-programming-languages)
* [Eloquent JavaScript, 1st Edition - Functional Programming](http://eloquentjavascript.net/1st_edition/chapter6.html)
* [Функциональное программирование на примере](http://tobyho.com/2015/11/09/functional-programming-by-example/)
* [Функциональное программирование на JavaScript - серия видео](https://www.youtube.com/watch?v=BMUiFMZr7vk&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84)
* [Введение в функциональный JavaScript](https://medium.com/functional-javascript/introduction-to-functional-javascript-45a9dca6c64a#.2qjh0i04y)
* [Как реализовать побочные эффекты в чистом функциональном программировании](http://stackoverflow.com/questions/18172947/how-to-perform-side-effects-in-pure-functional-programming)
* [Предотвращение побочных эффектов в JavaScript](https://davidwalsh.name/preventing-sideeffects-javascript)

* * *

Наблюдаемые объекты
-----------

**Обсерватории** похожи на массивы, только вместо того, чтобы храниться в памяти, элементы поступают асинхронно в течение времени (также называемые _потоками_). Мы можем _подписываться_ на наблюдаемые элементы и реагировать на события, испускаемые ими. Наблюдаемые объекты JavaScript являются реализацией [паттерна _наблюдателя_](http://stackoverflow.com/a/15596243). [Reactive Extensions](http://reactivex.io/) (широко известный как Rx\*) предоставляет библиотеку наблюдаемых для JS через [RxJS](https://github.com/ReactiveX/rxjs).

Чтобы продемонстрировать концепцию observables, рассмотрим простой пример: изменение размера окна браузера. В этом контексте легко понять, что такое наблюдаемые. Изменение размера окна браузера испускает поток событий в течение определенного периода времени, пока окно перетаскивается до нужного размера. Мы можем создать наблюдаемую и подписаться на нее, чтобы реагировать на поток событий изменения размера:

```js
    // создать поток изменений размера окна
    // дросселирование событий изменения размера
    const resize$ =
      Rx.Observable
        .fromEvent(window, 'resize')
        .throttleTime(350);
    
    // подписываемся на наблюдаемое событие resize$
    // регистрируем ширину и высоту окна
    const subscription =
      resize$.subscribe((event) => {
        let t = event.target;
        console.log(`${t.innerWidth}px x ${t.innerHeight}px`);
      });
```

Приведенный выше код примера показывает, что при изменении размера окна мы можем дросселировать поток наблюдаемых и подписаться на изменения, чтобы реагировать на новые значения в коллекции. Это пример _горячей наблюдаемой_.

### Горячие наблюдаемые (Hot Observables)

События пользовательского интерфейса, такие как нажатие кнопки, движение мыши и т.д., являются _горячими_. **Горячие наблюдаемые** всегда будут вызываться, даже если мы не реагируем на них с помощью подписки. Приведенный выше пример с изменением размера окна - это горячая наблюдаемая: наблюдаемая `resize$` срабатывает независимо от наличия или отсутствия `subscription`.

### Холодные наблюдаемые (Cold Observables)

**холодная наблюдаемая** начинает срабатывать только тогда, когда мы на нее подписались. Если мы подпишемся снова, то все начнется сначала.

Давайте создадим наблюдаемую коллекцию чисел от `1` до `5`:

```js
    // создадим исходный поток чисел
    const source$ = Rx.Observable.range(1, 5);
    
    // подписка на наблюдаемую коллекцию source$
    const subscription = source$.subscribe(
      (value) => { console.log(`Next: ${value}`); }, // onNext
      (event) => { console.log(`Error: ${event}`); }, // onError
      () => { console.log('Completed!'); }  // onCompleted
    );
```

Мы можем [`subscribe()`](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/subscribe.md) подписаться на только что созданную наблюдаемую `source$`. При подписке значения отправляются наблюдателю в последовательности. Обратный вызов `onNext` регистрирует значения: `Next: 1`, `Next: 2` и т.д. до завершения: `Completed!`. Холодная наблюдаемая `source$`, которую мы создали, не выполняет push, пока мы не подпишемся на нее.

### Наблюдаемые выводы

Наблюдаемые - это потоки. Мы можем наблюдать любой поток: от событий изменения размера до существующих массивов и ответов API. Мы можем создавать наблюдаемые практически из всего. Наблюдаемый объект _promise_ имеет единственное испускаемое значение, но наблюдаемые объекты могут возвращать множество значений с течением времени.

Мы можем оперировать с наблюдаемыми множеством способов. [RxJS использует множество методов операторов] (https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators). Наблюдаемые часто визуализируются с помощью точек на линии, как показано на сайте [RxMarbles](http://rxmarbles.com). Поскольку поток состоит из асинхронных событий в течение _времени_, его легко представить в линейном виде и использовать такую визуализацию для понимания операторов Rx\*. Например, следующее изображение RxMarbles иллюстрирует [оператор фильтрации](http://rxmarbles.com/#filter):

![реактивное программирование с Rx observables: оператор фильтра с сайта rxmarbles.com](https://images.ctfassets.net/23aumh6u8s0i/27dKGkRri9RqfCqtEEv4P0/ef8b0a693868c5d9106db7a49480ce4a/rxmarbles)

Чтобы узнать больше о **наблюдениях**, ознакомьтесь со следующими ресурсами:

* [Reactive Extensions: Observable](http://reactivex.io/documentation/observable.html)
* [Создание и подписка на простые последовательности Observable](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md)
* [Введение в реактивное программирование, которого вам не хватало: Запрос и ответ](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#request-and-response)
* [Введение в Observable](https://egghead.io/lessons/javascript-introducing-the-observable)
* [RxMarbles](http://rxmarbles.com/)
* [Rx Book - Observable](https://xgrommx.github.io/rx-book/content/observable/index.html)
* [Introducing the Observable](https://egghead.io/lessons/javascript-introducing-the-observable)

* * *

Реактивное программирование
--------------------

**Реактивное программирование** занимается распространением и реагированием на входящие события во времени, [декларативно](#императивно-декларативно) (описывая _что_ делать, а не _как_).

Реактивное программирование часто ассоциируется с [Reactive Extensions](http://reactivex.io/), API для асинхронного программирования с [наблюдаемыми потоками](#observables). Reactive Extensions (сокращенно Rx\*) [предоставляет библиотеки для различных языков](http://reactivex.io/languages.html), включая JavaScript ([RxJS](https://github.com/Reactive-Extensions/RxJS)).

### На практике: Реактивное программирование на JavaScript

Вот пример реактивного программирования с использованием наблюдаемых. Допустим, у нас есть вход, где пользователь может ввести шестисимвольный код подтверждения, и мы хотим вывести последнюю попытку ввода правильного кода. Наш HTML может выглядеть следующим образом:

```html
    <!-- HTML -->
    <input id="confirmation-code" type="text">
    <p>
      <strong>Valid code attempt:</strong>
      <code id="attempted-code"></code>
    </p>
```

Мы будем использовать RxJS и создадим поток событий ввода для реализации нашей функциональности, как показано ниже:

```js
    // JS
    const confCodeInput = document.getElementById('confirmation-code');
    const attemptedCode = document.getElementById('attempted-code');
    
    const confCodes$ =
      Rx.Observable
        .fromEvent(confCodeInput, 'input')
        .map(e => e.target.value)
        .filter(code => code.length === 6);
    
    const subscription = confCodes$.subscribe(
      (значение) => attemptedCode.innerText = значение,
      (event) => { console.warn(`Error: ${event}`); }
      () => { console.info('Completed!'); }
    );
```

Этот код можно запустить на этом [JSFiddle: Reactive Programming with JavaScript](https://jsfiddle.net/kmaida/v1ozuwgu/). Мы будем наблюдать [события от](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/fromevent.md) элемента ввода `confCodeInput`. Затем мы воспользуемся оператором [`map`](http://reactivex.io/documentation/operators/map.html), чтобы получить `значение` из каждого входного события. Затем мы [`фильтром`](http://reactivex.io/documentation/operators/filter.html) отфильтруем все результаты, которые не состоят из шести символов, чтобы они не появились в возвращаемом потоке. Наконец, мы [`подпишемся`](http://reactivex.io/documentation/operators/subscribe.html) на нашу наблюдаемую `confCodes$` и выведем последнюю попытку ввода кода подтверждения. Обратите внимание, что это было сделано в ответ на события во времени, декларативно: в этом суть реактивного программирования.

### Выводы из реактивного программирования

Парадигма реактивного программирования предполагает наблюдение и реагирование на события в асинхронных потоках данных. RxJS используется в [Angular](https://medium.com/google-developer-experts/angular-introduction-to-reactive-extensions-rxjs-a86a7430a61f#.41aap1i8a) и набирает популярность как JavaScript-решение для реактивного программирования.

Чтобы узнать больше о **реактивном программировании**, ознакомьтесь со следующими ресурсами:

* [Введение в реактивное программирование, которого вам не хватало](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)
* [Введение в Rx](http://www.introtorx.com/)
* [The Reactive Manifesto](http://www.reactivemanifesto.org/)
* [Понимание реактивного программирования и RxJS](https://auth0.com/blog/understanding-reactive-programming-and-rxjs/)
* [Реактивное программирование](http://paulstovell.com/blog/reactive-programming)
* [Модернизация реактивности](https://davidwalsh.name/modernization-reactivity)
* [Reactive-Extensions RxJS API Core](https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core)

* * *

Функциональное реактивное программирование
-------------------------------

Проще говоря, функциональное реактивное программирование можно описать как декларативное реагирование на события или поведение во времени. Чтобы глубже понять принципы FRP, давайте рассмотрим формулировку FRP. Затем мы рассмотрим ее применение в JavaScript.

### Что такое функционально-реактивное программирование?

[более полное определение](http://stackoverflow.com/a/5386908) от [Конала Эллиота, разработчика FRP](https://twitter.com/conal), гласит, что **функциональное реактивное программирование** является "[денотативным](https://en.wikibooks.org/wiki/Haskell/Denotational_semantics) и темпорально непрерывным". Эллиот упоминает, что он предпочитает описывать эту парадигму программирования как _денотативное программирование в непрерывном времени_ в отличие от "функционального реактивного программирования".

**Функциональное реактивное программирование**, в его самом основном, первоначальном определении, имеет два фундаментальных свойства:

* **денотативное**: значение каждой функции или типа является точным, простым и независимым от реализации ("функциональное" указывает на это)
* **непрерывное время**: [переменные имеют определенное значение в течение очень короткого времени: между любыми двумя точками находится бесконечное число других точек](https://en.wikipedia.org/wiki/Discrete_time_and_continuous_time#Continuous_time); обеспечивает гибкость преобразования, эффективность, модульность и точность ("реактивный" ссылается на это).

Опять же, если говорить просто: [**функциональное реактивное программирование** - это программирование декларативно с изменяющимися во времени значениями](https://www.quora.com/What-is-Functional-Reactive-Programming).

Чтобы понять _непрерывное время/временную непрерывность_, рассмотрим аналогию с векторной графикой. Векторная графика имеет _бесконечное разрешение_. В отличие от растровой графики (дискретное разрешение), векторная графика масштабируется неограниченно. Они никогда не пикселизируются и не становятся нечеткими при особенно больших или малых размерах, как это происходит с растровой графикой.

> "Выражения FRP описывают целые эволюции значений во времени, представляя эти эволюции непосредственно как первоклассные значения".
> 
> -_Конал Эллиот_

Функциональное реактивное программирование должно быть:

* динамичным: может реагировать во времени _или_ на изменения входных данных.
* изменяющимся во времени: реактивные _поведения_ могут изменяться постоянно, в то время как реактивные _значения_ изменяются дискретно
* эффективным: минимизировать объем обработки, необходимой при изменении входных данных
* историческая осведомленность: чистые функции отображают состояние из предыдущего момента времени в следующий момент времени; изменения состояния касаются локального элемента, а не глобального состояния программы.

Слайды Конала Эллиота на тему [Сущность и истоки FRP можно посмотреть здесь](http://conal.net/talks/essence-and-origins-of-frp-lambdajam-2015.pdf). Язык программирования [Haskell](https://wiki.haskell.org/Functional_Reactive_Programming) подходит для истинной FRP благодаря своей функциональной, чистой и ленивой природе. Эван Чаплицки, создатель [Elm](http://elm-lang.org), дает отличный обзор FRP в своем докладе [Controlling Time and Space: Understanding the Many Formulations of FRP](https://www.youtube.com/watch?v=Agu6jipKfYw).

На самом деле, давайте кратко поговорим о [Эване Чаплики](http://people.seas.harvard.edu/~chong/pubs/pldi13-elm.pdf) [Elm](https://auth0.com/blog/creating-your-first-elm-app-part-1/). Elm - это функциональный, типизированный язык для создания веб-приложений. Он компилируется в JavaScript, CSS и HTML. Архитектура [Elm](https://guide.elm-lang.org/architecture/) послужила вдохновением для создания контейнера состояний [Redux](http://redux.js.org/) для JS-приложений. [Изначально Elm считался настоящим функциональным реактивным языком программирования](https://www.youtube.com/watch?v=Agu6jipKfYw), но начиная с версии 0.17 в нем реализованы _подписки_ вместо сигналов в интересах упрощения изучения и использования языка. Тем самым Elm [попрощался с FRP](http://elm-lang.org/blog/farewell-to-frp).

### На практике: Функциональное реактивное программирование и JavaScript

Традиционное определение FRP может быть сложным для понимания, особенно для разработчиков, не имеющих опыта работы с такими языками, как Haskell или Elm. Однако в экосистеме front-end этот термин встречается все чаще, поэтому давайте прольем свет на его применение в JavaScript.

Чтобы примирить то, что вы, возможно, читали о FRP в JS, важно понять, что [Rx\*](https://www.sitepoint.com/functional-reactive-programming-rxjs/), [Bacon.js](https://baconjs.github.io/), [Angular](http://blog.angular-university.io/functional-reactive-programming-for-angular-2-developers-rxjs-and-observables/) и другие _не_ соответствуют двум основным принципам определения FRP, данного Коналом Эллиотом. [Эллиот утверждает, что Rx\* и Bacon.js не являются FRP. Вместо этого они являются "композиционными событийными системами, вдохновленными FRP"](https://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#comment36554089_5878525).

Функциональное реактивное программирование, _как оно относится конкретно к реализации JavaScript_, относится к программированию в [функциональном](#functional-programming) стиле при создании и реагировании на [потоки](#observables). Это довольно далеко от оригинальной формулировки Эллиота (которая [специально _исключает_ потоки как компонент](http://conal.net/talks/essence-and-origins-of-frp-lambdajam-2015.pdf)), но, тем не менее, вдохновлена традиционной FRP.

Также важно понимать, что JavaScript по своей природе взаимодействует с пользователем и пользовательским интерфейсом, DOM и часто бэкендом. [Побочные эффекты](#чистота) и [императивный](#императивно-декларативный) код являются обычным явлением, даже при использовании [функционального](#функционально-программного) или функционально-реактивного подхода. Без_ императивного или нечистого кода веб-приложение на JS с пользовательским интерфейсом было бы бесполезным, поскольку оно не могло бы взаимодействовать со своим окружением.

Давайте рассмотрим пример, демонстрирующий основные принципы _FRP-инспирированного_ JavaScript. Этот пример использует RxJS и выводит данные о движении мыши за период в десять секунд:

```js
    // создаем временную наблюдаемую, которая добавляет элемент каждые 1 секунду.
    // отобразите результирующий поток, чтобы он содержал значения событий
    const time$ =
      Rx.Observable
        .timer(0, 1000)
        .timeInterval()
        .map(e => e.value);
    
    // создаем наблюдаемое движение мыши
    // дроссель на каждые 350 мс
    // map, чтобы результирующий поток выталкивал объекты с координатами x и y
    const move$ =
      Rx.Observable
        .fromEvent(document, 'mousemove')
        .throttleTime(350)
        .map(e => { return {x: e.clientX, y: e.clientY} });
    
    // время слияния + потоки движения мыши
    // завершение через 10 секунд
    const source$ =
      Rx.Observable
        .merge(time$, move$)
        .takeUntil(Rx.Observable.timer(10000));
    
    // подписка на объединенную наблюдаемую source$
    // если значение - число, createTimeset()
    // если значение - объект координат, addPoint()
    const subscription =
      source$.subscribe(
        // onNext
        (x) => {
          if (typeof x === 'number') {
            createTimeset(x);
          } else {
            addPoint(x);
          }
        },
        // onError
        (err) => { console.warn('Error:', err); } }
        // onCompleted
        () => { console.info('Completed'); }
      );
    
    // добавляем элемент в DOM для перечисления точек, затронутых в определенную секунду
    function createTimeset(n) {
      const elem = document.createElement('div');
      const num = n + 1;
      elem.id = 't' + num;
      elem.innerHTML = `<strong>${num}</strong>: `;
      document.body.appendChild(elem);
    }
    
    // add points touched to latest time in stream
    function addPoint(pointObj) {
      // add point to last appended element
      const numberElem = document.getElementsByTagName('body')[0].lastChild;
      numberElem.innerHTML += ` (${pointObj.x}, ${pointObj.y}) `;
    }
```

Вы можете посмотреть этот код в действии в этом [JSFiddle: FRP-inspired JavaScript](https://jsfiddle.net/kmaida/3v8yw02s/). Запустите скрипку и проведите мышью по области результатов на экране, пока она считает до 10 секунд. Вы должны увидеть, что вместе со счетчиком появляются координаты мыши. Это указывает на то, где находилась ваша мышь в течение каждого 1-секундного интервала времени.

Давайте вкратце обсудим эту реализацию шаг за шагом.

Сначала мы создадим [наблюдаемую](#observables) переменную `time$`. Это таймер, который добавляет значение в коллекцию каждые `1000ms` (каждую секунду). Нам нужно `map` событие таймера, чтобы извлечь его `значение` и вставить его в результирующий поток.

Далее мы создадим наблюдаемую `move$` из события `document.mousemove`. Движение мыши является _непрерывным_. В любой точке последовательности есть бесконечное число точек между ними. Мы сократим это число, чтобы результирующий поток был более управляемым. Затем мы можем "отобразить" событие, чтобы вернуть объект со значениями `x` и `y` для представления координат мыши.

Далее мы хотим [объединить](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/merge.md) потоки `time$` и `move$`. Это оператор _объединения_. Таким образом, мы можем построить график того, какие движения мыши произошли в течение каждого временного интервала. Назовем полученную наблюдаемую `источник$`. Мы также ограничим наблюдаемую `source$` так, чтобы она завершалась через десять секунд (`10000ms`).

Теперь, когда у нас есть объединенный поток времени и движения, мы создадим `subscription` на наблюдаемую `source$`, чтобы мы могли реагировать на нее. В нашем обратном вызове `onNext` мы проверим, является ли значение `число` или нет. Если да, то мы хотим вызвать функцию `createTimeset()`. Если это объект координат, мы вызовем функцию `addPoint()`. В обратных вызовах `onError` и `onCompleted` мы просто запишем некоторую информацию.

Рассмотрим функцию `createTimeset(n)`. Мы создадим новый элемент `div` для каждого секундного интервала, обозначим его и добавим в DOM.

В функции `addPoint(pointObj)` мы выведем последние координаты в самом последнем таймсете `div`. Это свяжет каждый набор координат с соответствующим временным интервалом. Теперь мы можем прочитать, где находилась мышь с течением времени.

> **Примечание:** Эти функции являются [нечистыми](#purity): у них нет возвращаемого значения, и они также производят побочные эффекты. Побочные эффекты - это манипуляции с DOM. Как упоминалось ранее, JavaScript, который мы должны писать для наших приложений, часто взаимодействует с областью видимости за пределами своих функций.

### Функционально-реактивное программирование Основные моменты

FRP кодирует действия, реагирующие на события, используя чистые функции, которые отображают состояние от предыдущего момента времени до следующего момента времени. FRP в JavaScript не придерживается двух основных принципов FRP Конала Эллиота, но абстракции оригинальной концепции, безусловно, имеют ценность. JavaScript в значительной степени полагается на побочные эффекты и императивное программирование, но мы, безусловно, можем воспользоваться мощью концепций FRP для улучшения нашего JS.

Наконец, рассмотрим эту цитату из [первого издания Eloquent JavaScript](http://eloquentjavascript.net/1st_edition/), [второе издание доступно здесь](http://eloquentjavascript.net)):

> "Фу-Цзы написал небольшую программу, в которой было много глобального состояния и сомнительных сокращений. Прочитав ее, студент спросил: "Вы предостерегали нас от этих приемов, но я нахожу их в вашей программе. Как такое может быть?
> 
> Фу-Цзы сказал: "Нет нужды нести шланг за водой, когда дом не горит". {Это не следует понимать как поощрение небрежного программирования, а скорее как предостережение от невротического следования правилам большого пальца}".
> 
> -_Marijn Haverbeke, [Eloquent JavaScript, 1st Edition, Chapter 6](http://eloquentjavascript.net/1st_edition/chapter6.html)_

Чтобы узнать больше о **функциональном реактивном программировании (FRP)**, ознакомьтесь со следующими ресурсами:

* [Функционально-реактивное программирование для начинающих](https://www.youtube.com/watch?v=vLmaZxegahk)
* [The Functional Reactive Misconception](https://sideeffects.xyz/2015/the-functional-reactive-misconception/)
* [Что такое функционально-реактивное программирование?](http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631)
* [Haskell - функциональное реактивное программирование](https://wiki.haskell.org/Functional_Reactive_Programming)
* [Составление реактивных анимаций](http://conal.net/fran/tutorial.htm)
* [Спецификация языка функционального реактивного программирования](https://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525)
* [Более элегантная спецификация для FRP](https://github.com/conal/talk-2015-more-elegant-frp)
* [Функциональное реактивное программирование для начинающих](https://www.youtube.com/watch?v=vLmaZxegahk)
* [Elm - A Farewell to FRP](http://elm-lang.org/blog/farewell-to-frp)
* [Ранние вдохновения и новые направления в функциональном реактивном программировании](http://conal.net/blog/posts/early-inspirations-and-new-directions-in-functional-reactive-programming)
* [Breaking Down FRP](https://blogs.janestreet.com/breaking-down-frp/)
* [Rx\* не FRP](https://twitter.com/ReactiveX/status/483625917491970048)

* * *

В сторону: Использование JavaScript в Auth0
------------------------------

В Auth0 мы - [активные пользователи JavaScript] (https://github.com/auth0). От нашей [библиотеки блокировки](https://auth0.com/lock) до нашего бэкенда, JavaScript обеспечивает основу нашей работы. Мы считаем его асинхронную природу и низкий начальный барьер для новых разработчиков важными для нашего успеха. Нам не терпится увидеть, куда движется этот язык и какое влияние он окажет на свою экосистему.

[Зарегистрируйтесь для получения бесплатной учетной записи Auth0] (https://auth0.com/signup)

и взгляните из первых рук на готовую к производству экосистему, написанную на JavaScript. И не волнуйтесь, у нас есть [клиентские библиотеки для всех популярных фреймворков и платформ](https://auth0.com/docs/quickstarts)!

> [Auth0 предлагает щедрый **бесплатный уровень**](https://auth0.com/pricing), чтобы начать работу с современной аутентификацией.

Недавно мы выпустили продукт под названием [Auth0 Extend](https://auth0.com/extend/). Этот продукт позволяет компаниям предоставить своим клиентам простую в использовании точку расширения, которая принимает код JavaScript. С помощью [Auth0 Extend](https://auth0.com/extend/) клиенты могут создавать пользовательские бизнес-правила, задания по расписанию или подключаться к экосистеме, интегрируясь с другими SaaS-системами, такими как Marketo, Salesforce и Concur. И все это с помощью обычного JavaScript и модулей NPM.

Заключение
----------

В заключение приведем еще одну замечательную цитату из первого издания [Eloquent JavaScript](http://eloquentjavascript.net/1st_edition/):

> "Один студент часами неподвижно сидел за компьютером, мрачно нахмурившись. Он пытался написать красивое решение сложной задачи, но не мог найти правильный подход. Фу-цзы ударил его по затылку и крикнул: "Напиши что-нибудь!" Студент начал писать уродливое решение. После того как он закончил, он вдруг понял красивое решение".
> 
> -_Marijn Haverbeke, [Eloquent JavaScript, 1st Edition, Chapter 6](http://eloquentjavascript.net/1st_edition/chapter6.html)_

Концепции, необходимые для понимания [функционального программирования](#functional-programming), [реактивного программирования](#reactive-programming) и [функционально-реактивного программирования](#functional-reactive-programming), могут быть сложными для понимания, не говоря уже о _владении_. Написание кода, использующего преимущества основ парадигмы, - это начальный шаг, даже если поначалу он будет не совсем верным. Практика освещает путь вперед, а также выявляет потенциальные изменения.

Используя этот глоссарий в качестве отправной точки, вы можете начать использовать преимущества этих концепций и парадигм программирования, чтобы повысить свою компетентность в JavaScript. Если что-то еще неясно в этих темах, пожалуйста, обратитесь к ссылкам в каждом разделе, чтобы найти дополнительные ресурсы. Мы рассмотрим больше концепций в следующем посте Modern JS Glossary!

[![Иконка Twitter](https://cdn.auth0.com/website/blog/twitter-social-button.svg)](#)
[![Иконка LinkedIn](https://cdn.auth0.com/website/blog/linkedin-social-button.svg)](#)
[![Иконка Faceboook](https://cdn.auth0.com/website/blog/facebook-social-button.svg)](#)